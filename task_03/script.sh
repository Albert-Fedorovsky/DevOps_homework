#!/bin/bash

# Проверяем соответствует ли количество переданных скрипту аргументов необходимому
# для его корректной работы.
# if [ "$#" -ne 3 ];
if [ "$#" -lt 1 ];
 then
  echo "Illegal number of parameters"
  echo "Usage: $0 <application PID or name> <optional: seraching parameter name> <optional: number of strings to print>"
  exit 1
fi

# Устанавливаем значения обязательных для работы скрипта переменных
if [ "$#" -eq 1 ];
 then
  search_par="^Organization"
  strings_to_print="1000"
elif [ "$#" -eq 2 ];
 then
  search_par=$2
  strings_to_print="1000"
else
  search_par=$2
  strings_to_print=$3
fi

# Получаем PID или имя процесса, активность которого будем анализировать далее.
app_name=$1

# Проверяем, запустил ли пользователь анализ соединений при помощи утилиты ss
ss_enable="0"
if [ "$#" -ge 4 ];
 then
  if [ $4 == "ss" ];
   then
    app_name="."
    ss_enable="1"
    echo "ss mode ON"
  fi
fi

# Выводим установленное пользователем имя или PID искомого приложения .
echo "Application PID or name is: $app_name"

# Выводим установленное пользователем имя искомого парамета.
echo "Seraching parameter name is: $search_par"

# Выводим затребованное пользователем количество строк отчёта.
echo "Strings to print is no more then: $strings_to_print"

# ss - встроенная утилита для вывода данных, связанных с сетью,
# в различных форматах в зависимости от указанных опций.
# Опция -a позволяет отобразить все сокеты (открытые соединения).
# Утилита ss запускается, если в качестве четвёртого параметра в скрипт передана строка "ss"
# Собранная информация транслируется на дальнейшую обработку через переменную data
if [ $ss_enable == "1" ];
 then
  data=$(ss -a)

# Утилита netstat показывает содержимое различных структур данных, связанных с сетью,
# в различных форматах в зависимости от указанных опций. Значения опций:
# -t выводит список соединений TCP (Transmission Control Protocol)
# -u выводит список соединений UDP (User Datagram Protocol)
# -n дирректива: показывать сетевые адреса как числа (netstat обычно показывает адреса
#  как символы, эту опцию можно использовать с любым форматом показа)
# -a выводит писок всех портов (как TCP, так и UDP)
# -p выводит имя службы с её номером PID
# -l выводит список всех открытых (активных) входящих портов (соединений)
# Утилита netstat запускается по умолчанию
# Собранная информация транслируется на дальнейшую обработку через переменную data
 else
  data=$(netstat -tunapl)
fi

# awk - это инструмент для обработки и фильтрации текста. Читает стандартный поток вывода
# или файл (задаётся "опциями") по одной строке за раз, выполняет указанные в "условиях"
# "действия" и выводит результат на стандартный вывод.
# awk имеет слудющий формат: awk опции 'условие {действие} условие {действие}'
# В этом вызове awk выводит 5 (или 6 в режиме ss) слово из каждой строки содержащей,
# подстроку, задаваемую пользователем в первом аргументе, при вызове скрипта. А именно
# находит IP адреса активных соединений работающей программы, PID или имя которой задаёт
# пользователь первым аргументом при вызове скрипта.
# Собранная информация транслируется на дальнейшую обработку через переменную data
if [ $ss_enable == "1" ];
 then
  data=$(echo "$data" | awk -v app_name=$app_name '$0 ~ app_name {print $6}')
 else
  data=$(echo "$data" | awk -v app_name=$app_name '$0 ~ app_name {print $5}')
fi

# Команда cut используется, если нужно вырезать часть текста — при этом он может находиться
# в файле либо быть напечатанным через стандартный ввод, в зависимости от опций:
# -d опция устанавливает свой разделитель : вместо стандартного TAB.
# -f опция определяет перечень полей(номеров столбцов), которые следует вырезать.
# В этом вызове cut вырезает (оставляет) первый столбец отделённый символом : и транслирует
# результаты на дальнейшую обработку оператором  |
#cut -d: -f1 |
echo "$data" | cut -d: -f1 |

# Команда sort выполняет перестановку текстовых данных в заданном порядке.
# В этом вызове sort выполняет сортировку по возрастанию поступивших на его вход строк.
# Собранная информация транслируется на дальнейшую обработку оператором |
sort |

# Команда unic осуществляет поиск одинаковых строк в массивах текста. При этом сравниваютя
# только строки, находящиеся по соседству, т.е. массив текста должен отсортирован при
# помощи команды sort. С найденными совпадениями выполняются опреации, определяемые опциями:
# -c выводит в начале каждой строки, обозначающее количество повторов.
# В этом вызове unic удаляет повторяющиеся строки и  в начало каждой выводимой строки
# записывает число её повторов в исходном тексте.
# Собранная информация транслируется на дальнейшую обработку оператором |
uniq -c |

# В этом вызове sort также выполняет сортировку по возрастанию поступивших на его вход строк.
# Собранная информация транслируется на дальнейшую обработку оператором |
sort |

# Команда grep позволяет сортировать и фильтровать текст на основе сложных правил,
# определяемых опциями и шаблоном (регулярным выражением).
# Форматт команды: команда | grep [опции] шаблон.
# Команда - это то место, где будет вестись поиск.
# Опции - это дополнительные параметры, с помощью которых указываются различные настройки
# поиска и вывода, например количество строк или режим инверсии.
# Шаблон - это любая строка или регулярное выражение, по которому будет вестись поиск.
# Регулярное выражение описывает набор строк. Регулярные выражения конструируются аналогично
# арифметическим выражениям с использованием различных операторов для комбинирования более
# маленьких выражений. grep понимает три различных типа синтаксисов регулярных выражений:
# «basic» (BRE), «extended» (ERE) и «perl» (PCRE).
# Основными строительными блоками являются регулярные выражения, которые соответствуют
# единичному символу. Большинство символов, включая все буквы и цифры, являются регулярными
# выражениями, которые соответствуют самим себе. Любой метасимвол со специальным значением
# может использоваться в буквальном их значении, если перед ним поставить обратный слеш.
# . точка соответствует любому единичному символу, кроме перевода строки.
# \. - соответствует точке
# Пустое регулярное выражение соответствует пустой строке.
# () круглые скобки обозначают начало "(" и конец ")" подмаски.
# {} фигурные скобки обозначают начало "{" и конец "}" квантификатора
# {n} повторение, предыдущий элемент встречается ровно n раз
#  \ общий экранирующий символ.
#  + квантификатор, означающий одно или более выражений
# \d - любая десятичная цифра
# Опции:
# -o показывать только часть строки, совпадающую с шаблоном
# -P интерпретировать шаблон как совместимое с Perl регулярное выражение (PCRE).
# В этом вызове команда grep выделяет адреса соответствующие IPv4, иначе говоря ищет
# следующие подряд три секции из одной и более десятичных цифр, оканчивающихся точкой, при
# этом после третьей секции также должна следовать секция из одной или более десятичных цифр.
# Собранная информация транслируется на дальнейшую обработку оператором |
grep -oP '(\d+\.){3}\d+' |

# read — это встроенная команда bash, которая считывает строку из стандартного ввода
# (или из файлового дескриптора) и разбивает строку на слова. Первое слово присваивается
# первому имени, второе — второму имени и так далее. В данном случае read сохраняет только
# первую переменную, так как в качестве аргумента подставлено только одно имя "IP". Если
# read возвращает значение "true" (данные были считаны), выполняется очередная итерация
# цикла while.
while read IP ;

# В теле цикла while вызывается команда whois, которая выводит информацию о владельце
# интернет домена. В качестве аргумента whois может принимать URL и IP адреса.
# Собранная информация транслируется на дальнейшую обработку оператором |
do whois $IP |

# В этом вызове awk выводит 1 и 2 слова (поля) из каждой строки начинающейся содержащей
# слова, заданные пользователем, например "Organization", в качестве разделителя слов (полей)
# распознаётся ":" вместо стандартных пробельных символов то есть выводится перечень
# имён организаций владельцев домена, либо других других полей, по желанию пользователя.
# Собранная информация транслируется на дальнейшую обработку оператором |
awk -v search_par=$search_par -F':' '$0 ~ search_par {print $1 ":" $2}' ;
done |

# В этом вызове sort выполняет сортировку по возрастанию поступивших на его вход строк.
# Собранная информация транслируется на дальнейшую обработку оператором |
sort |

# В этом вызове unic удаляет повторяющиеся строки и  в начало каждой выводимой строки
# записывает число её повторов в исходном тексте (т. е. подсчитывает, сколько раз
# сколько соединений установлено с каждой организацией или параметром пользователя)
# Собранная информация транслируется на дальнейшую обработку оператором |
uniq -c |

# Добавляем пояснение к тому, что было подсчитано в отчёт:
# Собранная информация транслируется на дальнейшую обработку оператором |
while read output_string;
do echo "Number of connections: $output_string";
done |

# Команда tail выводит заданное количество строк с конца (хвоста) файла. Режим работы
# определяется опциями:
# -n задаёт количество сток, которые нужно вывести
# В этом вызове команда tail выводит, заданное пользователем во втором параметре,
# количество последних строк файла.
tail -n $strings_to_print

exit 0
